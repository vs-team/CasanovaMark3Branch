%{

open Common
open ParserAST
open System
open ParserUtils

%}

%start start

// Regular tokens
%token <int * (int * int)> INT
%token <float * (int * int)> FLOAT
%token <System.String * (int * int)> ID
%token <string * (int * int)> STRING
%token <(int * int)> UNIT
%token <System.Int32 * System.Int32> ARROW DARROW EQUAL
%token COMMA LBRACKET RBRACKET DOT APOSTROPHE HASH COLON NEWLINE BAR BIND
%token <int * int> FUNC TYPEFUNC OPEN INCLUDE DATA NAMESPACE IS FUN GT GEQ LT LEQ NEQ MAIN

%token EOF
 
%right ARROW DARROW

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type <ParserAST.Program> start

%%
// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced. 
start: program EOF { $1 }

newLineSeq:
| NEWLINE newLineSeq {  }
| NEWLINE {  }
| EOF {  }

program: NAMESPACE dottedPath newLineSeq includeOrOpenStmts subtypes declarations rules {
  $2,$4,($6,$7,$5) }

dottedPath:
| ID DOT dottedPath { (fst $1) + "." + $3 }
| ID { (fst $1) }

commaPath:
| ID COMMA commaPath { ({Namespace = ""; Name = fst $1}) :: $3 }
| ID { [{Namespace = "";Name = fst $1}] }

genericSeq:
| LT commaPath GT { $2 }
| { [] }

includeOrOpenStmts:
| includeOrOpenStmt includeOrOpenStmts { $1 :: $2 }
| { [] }

includeOrOpenStmt:
| INCLUDE dottedPath newLineSeq { $2 }
| OPEN dottedPath newLineSeq { $2 }

declarations:
| declaration declarations { 
  $1 :: $2 }
| { [] }

declaration:
| FUNC genericSeq typeOrNameDeclarations COLON typeDeclaration newLineSeq {
    Func(processParsedArgs $3 $5 (fst $1) (snd $1) $2) }
| DATA genericSeq typeOrNameDeclarations COLON typeDeclaration newLineSeq {
    Data(processParsedArgs $3 $5 (fst $1) (snd $1) $2) }

typeOrNameDeclarations:
| typeOrNameDeclaration ARROW typeOrNameDeclarations { $1 :: $3 }
| typeOrNameDeclaration { [$1] }
| { [] }

typeOrNameDeclaration:
| STRING { ParserUtils.Name(fst $1) }
| typeDeclaration { ParserUtils.Type($1) }

typeVarsSeq:
| typeDeclaration COMMA typeVarsSeq { $1 :: $3 }
| typeDeclaration { [$1] }

genericTypeDef:
| LT typeVarsSeq GT { $2 }
| { [] }

typeDeclaration:
| LBRACKET lambdaTypeDeclaration RBRACKET { $2 }
| APOSTROPHE ID { Generic({ Namespace = ""; Name = fst $2 })}
| ID genericTypeDef { Arg(Id({ Namespace = ""; Name = fst $1 },Position.Create(snd $1,"")),$2) }

lambdaTypeDeclaration: 
| typeDeclaration ARROW lambdaTypeDeclaration { Arrow($1,$3,true) }
| typeDeclaration { $1 }

arg:
| LBRACKET argSeq RBRACKET { NestedExpression($2) }
| literal { $1 }
| ID { Id({ Namespace = ""; Name = fst $1 },Position.Create(snd $1,"")) }

argSeq:
| arg argSeq { $1 :: $2 }
| arg { [$1] }

literal:
| INT { Literal(Common.I32(fst $1),Position.Create(snd $1,"")) }
| FLOAT { Literal(Common.F64(fst $1),Position.Create(snd $1,"")) }
| STRING { Literal(Common.String(fst $1),Position.Create(snd $1,"")) }
| UNIT { Literal(Common.Unit,Position.Create($1,"")) }

functionCall:
| argSeq ARROW argSeq newLineSeq { FunctionCall($1,$3) }

comparisonOp:
| GT { Greater }
| GEQ { GreaterEqual }
| LT { Less }
| LEQ { LessEqual }
| EQUAL { Equal }
| NEQ { NotEqual }

premises:
| functionCall premises { $1 :: $2 }
| ID BIND arg newLineSeq premises { (Bind({ Namespace = ""; Name = fst $1 },Position.Create(snd $1,""),$3)) :: $5 }
| arg comparisonOp arg newLineSeq premises { (Conditional($1,$2,$3)) :: $5 }
| { [] }

conclusion:
| argSeq ARROW argSeq newLineSeq { ValueOutput($1,$3) }

fractionLine:
| BAR fractionLine {  }
| BAR {  }

subtype: ID IS ID newLineSeq { Arg(Id( { Namespace = ""; Name = fst $1  },Position.Create(snd $1,"")),[]),Arg(Id({ Namespace = ""; Name = fst $3 },Position.Create(snd $1,"")),[]) }

subtypes:
| subtype subtypes { $1 :: $2 }
| { [] }

mainOpt:
| MAIN COLON newLineSeq { true }
| { false }

rule: mainOpt premises fractionLine newLineSeq conclusion { Rule({ Main = $1; Premises = $2; Conclusion = $5 }) }

rules:
| rule rules { $1 :: $2 }
| { [] }