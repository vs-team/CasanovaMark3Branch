%{

open Common
open ParserAST
open System
open ParserUtils

%}

%start start

// Regular tokens
%token <int * (int * int)> INT
%token <float * (int * int)> FLOAT
%token <System.String * (int * int)> ID
%token <string * (int * int)> STRING
%token <System.Int32 * System.Int32> ARROW DARROW EQUAL
%token COMMA LBRACKET RBRACKET DOT APOSTROPHE HASH COLON NEWLINE BAR
%token <int * int> FUNC TYPEFUNC OPEN INCLUDE DATA MODULE

%token EOF
 
%right ARROW DARROW

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type <ParserAST.CallArg list> start

%%
// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced. 
start: argSeq EOF { $1 }

newLineSeq:
| NEWLINE newLineSeq {  }
| NEWLINE {  }
| EOF {  }

program: MODULE dottedPath newLineSeq includeOrOpenStmts declarations rules {
  $2,$4,($5,$6,[]) }

dottedPath:
| ID DOT dottedPath { (fst $1) + "." + $3 }
| ID { (fst $1) }

includeOrOpenStmts:
| includeOrOpenStmt includeOrOpenStmts { $1 :: $2 }
| { [] }

includeOrOpenStmt:
| INCLUDE dottedPath newLineSeq { $2 }
| OPEN dottedPath newLineSeq { $2 }

declarations:
| declaration declarations { 
  printfn "Declaration found"
  $1 :: $2 }
| { [] }

declaration:
| FUNC typeOrNameDeclarations DARROW typeDeclaration newLineSeq {
    printfn "Function found"
    Func(processParsedArgs $2 $4 (fst $1) (snd $1)) }
| DATA typeOrNameDeclarations DARROW typeDeclaration newLineSeq {
    printfn "Data found"
    Data(processParsedArgs $2 $4 (fst $1) (snd $1)) }

typeOrNameDeclarations:
| typeOrNameDeclaration ARROW typeOrNameDeclarations { $1 :: $3 }
| typeOrNameDeclaration { [$1] }
| { [] }

typeOrNameDeclaration:
| STRING { ParserUtils.Name(fst $1) }
| typeDeclaration { ParserUtils.Type($1) }


typeDeclaration:
| LBRACKET lambdaTypeDeclaration RBRACKET { printfn "lambda found"; $2 }
| APOSTROPHE ID { printfn "Generic found"; Generic({ Namespace = ""; Name = fst $2 })}
| ID { Arg(Id({ Namespace = ""; Name = fst $1 },Position.Create(snd $1,""))) }

lambdaTypeDeclaration: 
| typeDeclaration ARROW lambdaTypeDeclaration { printfn "Arrow found"; Arrow($1,$3) }
| typeDeclaration { $1 }

arg:
| LBRACKET argSeq RBRACKET { NestedExpression($2) }
| literal { $1 }
| ID { Id({ Namespace = ""; Name = fst $1 },Position.Create(snd $1,"")) }

argSeq:
| arg argSeq { $1 :: $2 }
| arg { [$1] }

literal:
| INT { Literal(Common.I32(fst $1),Position.Create(snd $1,"")) }
| FLOAT { Literal(Common.F64(fst $1),Position.Create(snd $1,"")) }
| STRING { Literal(Common.String(fst $1),Position.Create(snd $1,"")) }

functionCall:
| argSeq ARROW argSeq newLineSeq { FunctionCall($1,$3) }

premises:
| functionCall premises { $1 :: $2 }
| { [] }

conclusion:
| argSeq ARROW argSeq newLineSeq { ValueOutput($1,$3) }

fractionLine:
| BAR fractionLine {  }
| BAR {  }

rule: premises fractionLine conclusion { Rule($1,$3) }

rules:
| rule rules { $1 :: $2 }
| { [] }
